// Copyright 2022 Adam Chalkley
//
// https://github.com/atc0005/check-restart
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/atc0005/check-restart/internal/config"
	"github.com/atc0005/check-restart/internal/restart"
	"github.com/atc0005/check-restart/internal/restart/files"
	"github.com/atc0005/check-restart/internal/restart/registry"
	"github.com/atc0005/check-restart/internal/restart/reports"
	"github.com/atc0005/go-nagios"

	"github.com/rs/zerolog"
)

func main() {
	// Start the timer. We'll use this to emit the plugin runtime as a
	// performance data metric.
	pluginStart := time.Now()

	// Set initial "state" as valid, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags.
	cfg, cfgErr := config.New(config.AppType{Plugin: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:

		// We make some assumptions when setting up our logger as we do not
		// have a working configuration based on sysadmin-specified choices.
		consoleWriter := zerolog.ConsoleWriter{Out: os.Stderr}
		logger := zerolog.New(consoleWriter).With().Timestamp().Caller().Logger()

		logger.Err(cfgErr).Msg("Error initializing application")

		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.AddError(cfgErr)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	// Collect last minute details just before ending plugin execution.
	defer func(exitState *nagios.ExitState, start time.Time, logger zerolog.Logger) {

		// Record plugin runtime, emit this metric regardless of exit
		// point/cause.
		runtimeMetric := nagios.PerformanceData{
			Label: "time",
			Value: fmt.Sprintf("%dms", time.Since(start).Milliseconds()),
		}
		if err := exitState.AddPerfData(false, runtimeMetric); err != nil {
			logger.Error().
				Err(err).
				Msg("failed to add time (runtime) performance data metric")
		}
	}(&nagiosExitState, pluginStart, cfg.Log)

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	switch cfg.LoggingLevel == config.LogLevelDebug {
	case true:
		restart.EnableLogging()
		files.EnableLogging()
		registry.EnableLogging()
		reports.EnableLogging()
	default:
		restart.DisableLogging()
		files.DisableLogging()
		registry.DisableLogging()
		reports.DisableLogging()
	}

	log := cfg.Log.With().Logger()

	log.Debug().Msg("Retrieving default registry reboot assertions")
	registryAssertions := registry.DefaultRebootRequiredAssertions()
	log.Debug().
		Int("registry_assertions", len(registryAssertions)).
		Msg("Retrieved default registry reboot assertions")

	log.Debug().Msg("Retrieving default file reboot assertions")
	fileAssertions := files.DefaultRebootRequiredAssertions()
	log.Debug().
		Int("file_assertions", len(fileAssertions)).
		Msg("Retrieved default file reboot assertions")

	log.Debug().Msg("Finished retrieving reboot assertions")

	allAssertions := make(restart.RebootRequiredAsserters, 0, len(registryAssertions)+len(fileAssertions))
	allAssertions = append(allAssertions, registryAssertions...)
	allAssertions = append(allAssertions, fileAssertions...)
	log.Debug().
		Int("all_assertions", len(allAssertions)).
		Msg("All assertions retrieved")

	log.Debug().Msg("Validating assertions collection")
	if err := allAssertions.Validate(); err != nil {
		log.Error().Err(err).Msg("Failed to validate provided assertions")

		nagiosExitState.AddError(err)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Failed to validate list of reboot evaluations",
			nagios.StateCRITICALLabel,
		)

		return
	}

	log.Debug().Msg("Evaluating reboot assertions")
	results := make(restart.RebootCheckResults, 0, len(allAssertions))
	for _, assertion := range allAssertions {
		result := assertion.Evaluate()
		results = append(results, result)

		if result.Err != nil {
			switch {
			case errors.Is(result.Err, restart.ErrMissingOptionalItem):
				log.Debug().
					// Err(result.Err).
					Str("assertion", assertion.String()).
					Msg("Optional reboot assertion not found")
			default:
				log.Error().
					Err(result.Err).
					Str("assertion", assertion.String()).
					Msg("Error occurred evaluating required reboot assertion")
			}

		}
	}

	pd := []nagios.PerformanceData{
		// The `time` (runtime) metric is appended at plugin exit, so do not
		// duplicate it here.
		{
			Label: "evaluated_assertions",
			Value: fmt.Sprintf("%d", len(allAssertions)),
		},
		{
			Label: "evaluated_file_assertions",
			Value: fmt.Sprintf("%d", len(fileAssertions)),
		},
		{
			Label: "evaluated_registry_assertions",
			Value: fmt.Sprintf("%d", len(registryAssertions)),
		},
		{
			Label: "matched_assertions",
			Value: fmt.Sprintf("%d", results.RebootAssertionsMatched()),
		},
		{
			Label: "errors",
			Value: fmt.Sprintf("%d", results.NumErrors()),
		},
	}

	switch {
	case !results.IsOKState():

		if results.RebootRequired() {
			log.Debug().
				Int("num_reboot_assertions_applied", results.RebootAssertionsApplied()).
				Int("num_reboot_assertions_matched", results.RebootAssertionsMatched()).
				Msg("Reboot assertions matched, reboot needed")

			nagiosExitState.AddError(restart.ErrRebootRequired)
		}

		// Include all errors collected during evaluation.
		if results.HasErrors() {
			log.Error().
				Int("num_reboot_assertions_applied", results.RebootAssertionsApplied()).
				Int("num_errors", results.NumErrors()).
				Msg("Errors encountered evaluating need for reboot")

			nagiosExitState.AddError(results.Errs()...)
		}

		nagiosExitState.ExitStatusCode = results.ServiceState().ExitCode

		nagiosExitState.ServiceOutput = reports.CheckRebootOneLineSummary(results)
		nagiosExitState.LongServiceOutput = reports.CheckRebootReport(results, cfg.VerboseOutput)

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		return

	// No errors, no reboot needed.
	default:
		log.Debug().
			Int("num_reboot_assertions_applied", results.RebootAssertionsApplied()).
			Int("num_reboot_assertions_matched", results.RebootAssertionsMatched()).
			// Msg("No (non-ignored) reboot assertions matched")
			Msg("No reboot assertions matched")

		nagiosExitState.ServiceOutput = reports.CheckRebootOneLineSummary(results)
		nagiosExitState.LongServiceOutput = reports.CheckRebootReport(results, cfg.VerboseOutput)

		nagiosExitState.ExitStatusCode = results.ServiceState().ExitCode

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		return

	}

}
