// Copyright 2022 Adam Chalkley
//
// https://github.com/atc0005/check-restart
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/atc0005/check-restart/internal/config"
	"github.com/atc0005/check-restart/internal/restart"
	"github.com/atc0005/check-restart/internal/restart/files"
	"github.com/atc0005/check-restart/internal/restart/registry"
	"github.com/atc0005/check-restart/internal/restart/reports"
	"github.com/atc0005/go-nagios"

	"github.com/rs/zerolog"
)

func main() {
	// Start the timer. We'll use this to emit the plugin runtime as a
	// performance data metric.
	pluginStart := time.Now()

	// Set initial "state" as valid, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags.
	cfg, cfgErr := config.New(config.AppType{Plugin: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:

		// We make some assumptions when setting up our logger as we do not
		// have a working configuration based on sysadmin-specified choices.
		consoleWriter := zerolog.ConsoleWriter{Out: os.Stderr, NoColor: true}
		logger := zerolog.New(consoleWriter).With().Timestamp().Caller().Logger()

		logger.Err(cfgErr).Msg("Error initializing application")

		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.AddError(cfgErr)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	// Collect last minute details just before ending plugin execution.
	defer func(exitState *nagios.ExitState, start time.Time, logger zerolog.Logger) {

		// Record plugin runtime, emit this metric regardless of exit
		// point/cause.
		runtimeMetric := nagios.PerformanceData{
			Label: "time",
			Value: fmt.Sprintf("%dms", time.Since(start).Milliseconds()),
		}
		if err := exitState.AddPerfData(false, runtimeMetric); err != nil {
			logger.Error().
				Err(err).
				Msg("failed to add time (runtime) performance data metric")
		}
	}(&nagiosExitState, pluginStart, cfg.Log)

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	switch {
	case zerolog.GlobalLevel() == zerolog.DebugLevel ||
		zerolog.GlobalLevel() == zerolog.TraceLevel:
		restart.EnableLogging()
		files.EnableLogging()
		registry.EnableLogging()
		reports.EnableLogging()
	default:
		restart.DisableLogging()
		files.DisableLogging()
		registry.DisableLogging()
		reports.DisableLogging()
	}

	log := cfg.Log.With().Logger()

	log.Debug().Msg("Retrieving default registry reboot assertions")
	registryAssertions := registry.DefaultRebootRequiredAssertions()
	log.Debug().
		Int("registry_assertions", len(registryAssertions)).
		Msg("Retrieved default registry reboot assertions")

	log.Debug().Msg("Retrieving default file reboot assertions")
	fileAssertions := files.DefaultRebootRequiredAssertions()
	log.Debug().
		Int("file_assertions", len(fileAssertions)).
		Msg("Retrieved default file reboot assertions")

	log.Debug().Msg("Finished retrieving reboot assertions")

	allAssertions := make(restart.RebootRequiredAsserters, 0, len(registryAssertions)+len(fileAssertions))
	allAssertions = append(allAssertions, registryAssertions...)
	allAssertions = append(allAssertions, fileAssertions...)

	log.Debug().
		Int("all_assertions", len(allAssertions)).
		Msg("All assertions retrieved")

	log.Debug().Msg("Validating assertions collection")
	if err := allAssertions.Validate(); err != nil {
		log.Error().Err(err).Msg("Failed to validate provided assertions")

		nagiosExitState.AddError(err)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Failed to validate list of reboot evaluations",
			nagios.StateCRITICALLabel,
		)

		return
	}

	log.Debug().Msg("Evaluating reboot assertions")
	allAssertions.Evaluate()

	switch {
	case cfg.DisableDefaultIgnored:
		log.Debug().Msg("Skipping use of default ignored path entries for reboot assertions")
	default:
		log.Debug().Msg("Retrieving default ignored path entries for registry reboot assertions")
		registryignorePatterns := registry.DefaultRebootRequiredIgnoredPaths()
		log.Debug().
			Int("registry_ignore_patterns", len(registryignorePatterns)).
			Msg("Retrieved default registry ignore path patterns")

		log.Debug().Msg("Retrieving default ignored path entries for file assertions")
		fileignorePatterns := files.DefaultRebootRequiredIgnoredPaths()
		log.Debug().
			Int("file_ignore_patterns", len(fileignorePatterns)).
			Msg("Retrieved default file ignore path patterns")

		log.Debug().Msg("Finished retrieving default ignored path entries")

		allIgnorePatterns := make([]string, 0, len(registryignorePatterns)+len(fileignorePatterns))
		allIgnorePatterns = append(allIgnorePatterns, registryignorePatterns...)
		allIgnorePatterns = append(allIgnorePatterns, fileignorePatterns...)

		log.Debug().Msg("Filtering reboot assertions")

		allAssertions.Filter(allIgnorePatterns)
	}

	pd := []nagios.PerformanceData{
		// The `time` (runtime) metric is appended at plugin exit, so do not
		// duplicate it here.
		{
			Label: "evaluated_assertions",
			Value: fmt.Sprintf("%d", len(allAssertions)),
		},
		{
			Label: "evaluated_file_assertions",
			Value: fmt.Sprintf("%d", len(fileAssertions)),
		},
		{
			Label: "evaluated_registry_assertions",
			Value: fmt.Sprintf("%d", len(registryAssertions)),
		},
		{
			Label: "matched_assertions",
			Value: fmt.Sprintf("%d", allAssertions.NumMatched()),
		},
		{
			Label: "ignored_assertions",
			Value: fmt.Sprintf("%d", allAssertions.NumIgnored()),
		},
		{
			Label: "errors",
			Value: fmt.Sprintf("%d", allAssertions.NumErrors(false)),
		},
	}

	switch {
	case !allAssertions.IsOKState():

		log.Debug().Msg("case !allAssertions.IsOKState() triggered")

		if allAssertions.RebootRequired() {

			// If emitted by default NSClient++ will send back stderr and
			// stdout blended together.
			//
			// The standard deployment procedure (if emitting this at Error
			// level) will likely become explicitly disabling logging entirely
			// in order to avoid this message displaying within the Nagios web
			// UI and notifications by default.
			//
			// Because it would be beneficial to have logging enabled by
			// default and left on by the sysadmin, we need to ensure that only
			// "real" issues are emitted by default.
			log.Debug().
				Int("assertions_applied", allAssertions.NumApplied()).
				Int("assertions_matched", allAssertions.NumMatched()).
				Int("assertions_ignored", allAssertions.NumIgnored()).
				Msg("Reboot assertions matched, reboot needed")

			nagiosExitState.AddError(restart.ErrRebootRequired)
		}

		log.Debug().Msg("allAssertions.RebootRequired() NOT triggered")

		// Include all errors collected during evaluation. Don't include
		// errors from assertions marked as ignored.
		if allAssertions.HasErrors(false) {
			log.Error().
				Int("assertions_applied", allAssertions.NumApplied()).
				Int("assertions_matched", allAssertions.NumMatched()).
				Int("assertions_ignored", allAssertions.NumIgnored()).
				Int("errors", allAssertions.NumErrors(false)).
				Msg("Errors encountered evaluating need for reboot")

			nagiosExitState.AddError(allAssertions.Errs(false)...)
		}

		log.Debug().Msg("allAssertions.HasErrors(false) NOT triggered")

		nagiosExitState.ExitStatusCode = allAssertions.ServiceState().ExitCode

		nagiosExitState.ServiceOutput = reports.CheckRebootOneLineSummary(allAssertions, false)
		nagiosExitState.LongServiceOutput = reports.CheckRebootReport(allAssertions, cfg.ShowIgnored, cfg.VerboseOutput)

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		return

	default:

		log.Debug().Msg("default case for overall plugin state triggered")

		log.Debug().
			Int("num_reboot_assertions_applied", allAssertions.NumApplied()).
			Int("num_reboot_assertions_matched", allAssertions.NumMatched()).
			Msg("No (non-ignored) reboot assertions matched")

		nagiosExitState.ServiceOutput = reports.CheckRebootOneLineSummary(allAssertions, false)
		nagiosExitState.LongServiceOutput = reports.CheckRebootReport(allAssertions, cfg.ShowIgnored, cfg.VerboseOutput)

		nagiosExitState.ExitStatusCode = allAssertions.ServiceState().ExitCode

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		return

	}

}
